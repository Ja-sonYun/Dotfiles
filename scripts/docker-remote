#!/usr/bin/env bash
# docker-remote
#
# Author: Ja-sonYun<killa30867@gmail.com>
# Date: 2022-07-30
# Version: 1.0.0
#
# Description
# -----------
# Run docker with remote access.
# Use single ssh socket for communicate between remote server.
# Upload only modified files to remote server, and download only
# newly modified files from remote server.
#
# ╭──────╮              ╭────────╮
# │ host │              │ remote │
# ╰───┬──╯              ╰────┬───╯
#     │                      │
#     │                      │
#     │   upload context     │
#     ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌▶│
#     │                      │
#     │                      │ run docker command
#     │   sync every 2 sec   ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╮
#     ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌▶│                   │
#     │                      │◀╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╯
#     │                      │
#     │ download context     │
#     │ after docker command │
#     │◀╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
#     │                      │
#     │                      │
#
# Configuration
# -------------
# Create file under root of project named '.remote_info'
# with the following content:
CONF="\
REMOTE_HOST=user@192.168.0.1:22
REMOTE_TEMP_DIR=
PORTS=<localport>:<remoteport>,
EXCLUDE=.venv,.git"
#
# Usage
# -----
# $ docker-remote ps
# $ docker-remote compose up
# $ docker-remote build - < context.tar.gz
#
declare -A remote_info
HOST_INFO_FILE=".docker_remote"

function load_remote_info() {
    if [ ! -f "$HOST_INFO_FILE" ]; then
        echo "Error: $HOST_INFO_FILE not found"
        read -r -p "Create new configuration file? (.docker_remote) [y/N] " response
        response=${response,,}    # tolower
        if [[ "$response" =~ ^(yes|y)$ ]]; then
            echo "$CONF" > "$HOST_INFO_FILE"
        fi
        exit 1
    fi

    while IFS='=' read -r key value; do
        remote_info[$key]=$value
    done < $HOST_INFO_FILE
}

function save_remote_info() {
    : > $HOST_INFO_FILE
    for k in "${!remote_info[@]}"; do
        echo "$k=${remote_info[$k]}" >> $HOST_INFO_FILE
    done
}

function ensure_command() {
    if ! command -v $1 $> /dev/null; then
        echo "Error: $1 is not installed"
        exit 1
    fi
}

# close session when this script is stopped
ALL_TRAPS="ssh -O exit -S $SOCK $USER@$ADDR &> /dev/null; \
      trap - SIGTERM &> /dev/null && kill -- -$$ &> /dev/null"
function new_trap() {
    trap "$1;$ALL_TRAPS" SIGINT SIGTERM EXIT
    ALL_TRAPS="$1;$ALL_TRAPS"
}
# ===========================================
# Main
load_remote_info
# If key does not exists, register
if [[ "${remote_info[KEY]}" == "" ]]; then
    remote_info[KEY]=$(openssl rand -hex 20)
    save_remote_info
fi
IFS=' ' read -r -a opts <<< "$@"

SHOULD_MOUNT_OPTS=("build" "compose" "buildx")
SHOULD_MOUNT=false
for kwd_opt in "${SHOULD_MOUNT_OPTS[@]}" ; do
    if [[ " ${opts[*]} " =~ " ${kwd_opt} " ]]; then
        SHOULD_MOUNT=true
    fi
done

FULL_ADDR="${remote_info[REMOTE_HOST]}"

# Parse username @ addr
IFS='@' read -r -a parse_user_addr <<< "$FULL_ADDR"
USER=${parse_user_addr[0]}
# Parse addr : port
IFS=':' read -r -a parse_addr_port <<< "${parse_user_addr[1]}"
ADDR=${parse_addr_port[0]}
PORT=${parse_addr_port[1]}

if [[ "$PORT" == "" ]]; then
    PORT=22
fi

ensure_command "rsync"
ensure_command "readlink"
ensure_command "ssh"
ensure_command "openssl"

# create folder to save sockets
mkdir -p $HOME/.ssh/sockets
SOCK=$HOME/.ssh/sockets/$FULL_ADDR.sock

function multiplex_ssh() {
    # Send command via multiplex session
    # ----------------------------------
    # $1 : Command to run
    ssh -o "ControlMaster=auto" -o "ControlPersist=yes" -p $PORT $2 \
        -S $SOCK $USER@$ADDR "$1"
}

# Check the host is linux nor windows
multiplex_ssh "uname" &> /dev/null
if [[ $? == 1 ]]; then
    echo "Error: This script only can use with a LINUX or MACOSX."
    exit 1
fi

function ensure_remote_command() {
    command=$(multiplex_ssh "command -v $1")

    if [ "$command" == "" ]; then
        echo "Error: $1 is not installed on remote server"
        exit 1
    fi
}

ensure_remote_command "ssh"
ensure_remote_command "docker"
ensure_remote_command "sshfs"

# Create folder to save folder path generated by mktemp on remote host
FOUND_PREV_PATH=false
if [[ "${remote_info[REMOTE_TEMP_DIR]}" != "" ]]; then
    prev_temp_path="${remote_info[REMOTE_TEMP_DIR]}"
    is_temp_yes=$(multiplex_ssh "[ -f \"$prev_temp_path/$HOST_INFO_FILE\" ] && echo 'yes'")
    # If previous temporary directory still exists in remote host, re-use it
    if [[ "$is_temp_yes" == "yes" ]]; then
        # Compare that configuration file include key
        REMOTE_KEY=$(multiplex_ssh "cat $prev_temp_path/$HOST_INFO_FILE")
        if [[ "$REMOTE_KEY" == *"${remote_info[KEY]}"* ]]; then
            temp_folder_remote=$prev_temp_path
            FOUND_PREV_PATH=true
        fi
    fi
fi


# If couldn't find previous path, create new temporary directory
if [[ $FOUND_PREV_PATH == false ]]; then
    temp_folder_remote=$(multiplex_ssh "mktemp -d")
    remote_info[REMOTE_TEMP_DIR]="$temp_folder_remote"
fi

RSYNC_EXCLUDE="\
    --exclude=.git \
    --exclude=.gitignore \
    --exclude=.gitmodules \
    --exclude=.DS_Store \
    --exclude=.venv"
IFS=',' read -r -a exclude <<< "${remote_info[EXCLUDE]}"
for file in "${exclude[@]}"; do
    RSYNC_EXCLUDE="$RSYNC_EXCLUDE --exclude=$file"
done

function sync_fs() {
    # Sync local folder to remote folder
    # ----------------------------------
    # $1 : Local folder path
    # $2 : Remote folder path
    EXTRA_OPTS="$3"
    rsync -avz $3 \
        --rsh="ssh -p $PORT -o 'ControlPath=$SOCK'" \
        $1 $2 $RSYNC_EXCLUDE &> /dev/null
}

function fetch_fs() {
    while true; do
        sync_fs $1 $2 --delete
        sleep 2
        if [ -f "$SOCK" ]; then
            break
        fi
    done
}

function upload_fs() {
    fswatch -0 . | \
    while read -d "" mf; do
        sync_fs $1 $2 --delete
        if [ -f "$SOCK" ]; then
            break
        fi
    done
}

function mount_fs() {
    # Mount remote folder to local folder
    # ----------------------------------
    # $1 : Local folder path
    # $2 : Remote folder path
    FULL_LINK=$(readlink -f $1)
    LOCAL_USER=$(whoami)
    LOCAL_HOST=$(hostname)
    TUNNEL=10000
    SSHFS_OPTS=""
    if [ "$FOUND_PREV_PATH" == true ]; then
        SSHFS_OPTS="-o nonempty"
    fi

    ssh -Nf $USER@$ADDR -p $PORT -o 'ControlPath=$SOCK' -R $TUNNEL:$LOCAL_HOST:22 &> /dev/null

    echo -n "Local Password: "
    read -s password
    echo ""
    uid=$(multiplex_ssh "id -u \$(whoami)")
    gid=$(multiplex_ssh "id -g \$(whoami)")
    echo -ne "$password" | multiplex_ssh "sshfs -o password_stdin -o allow_other -o uid=$uid,gid=$gid \
        $SSHFS_OPTS -p $TUNNEL $LOCAL_USER@127.0.0.1:$FULL_LINK $2"
    new_trap "multiplex_ssh \"fusermount -u $2\""
}

# sync_fs . $USER@$ADDR:$temp_folder_remote --delete
# fetch_fs $USER@$ADDR:$temp_folder_remote . &

# Upload if file modified
# upload_fs . $USER@$ADDR:$temp_folder_remote &

# Run docker compose
DOCKER_OPTS="${opts[@]}"

# Bind ports
if [[ "${remote_info[PORTS]}" != "" ]]; then
    IFS=',' read -r -a ports_list <<< "${remote_info[PORTS]}"
    port_forwarding_cmds=""
    for port in "${ports_list[@]}"; do
        IFS=':' read -r -a port_info <<< "$port"
        port_forwarding_cmds="$port_forwarding_cmds -L ${port_info[0]}:127.0.0.1:${port_info[1]}"
    done
    ssh -Nf -o "ControlPath=$SOCK" $port_forwarding_cmds $USER@$ADDR &> /dev/null
fi

# Mount local filesystem to remote server
if [ "$SHOULD_MOUNT" == true ]; then
    mount_fs . $temp_folder_remote
    sleep 50000
    multiplex_ssh "cd $temp_folder_remote && ls -la"
fi


# Force pseudo-tty allocation, to allow sigint the process
# trap sigint to ignore ctrl-c while ssh is running on background
# trap ":" INT
multiplex_ssh "cd $temp_folder_remote && docker $DOCKER_OPTS" -t

# Download any diff from remote
# echo "Syncing with remote context..."
# sync_fs $USER@$ADDR:$temp_folder_remote/* . --delete

# Save updated host info, last temporary directory will be updated.
